use std::collections::HashMap;
use std::future::{ready, Ready};
use futures_util::{future::LocalBoxFuture};
use actix_web::{
    cookie,
    dev::{
        forward_ready, Service, ServiceRequest,
        ServiceResponse, Transform
    },
    error::Error,
    HttpMessage
};

mod utils;
mod ip_validator;
mod renderer;
mod captcha;
// TODO: Implement middleware that verifies the client's IP address and caches the results in Redis.
// TODO: If the IP address is identified as malicious or invalid, display the check.html page with the appropriate translations,
// TODO: along with the current proof-of-work state and challenge. If JavaScript is disabled, display captcha.html instead.
// TODO: The captcha.html page should be generated by loading AI-generated images from files at application startup.
// TODO: Each request will distort these images and store the correct versions along with a timestamp and the corresponding IP address
// TODO: for correlation purposes. All templates and AI datasets should be preloaded into memory at startup for efficient access.


#[derive(Default)]
pub struct RequestCookies(HashMap<String, String>);

pub fn add_cookie(req: &ServiceRequest, key: String, value: String) {
    if let Some(cookies) = req.extensions_mut().get_mut::<RequestCookies>() {
        cookies.0.insert(key, value);
    } else {
        let mut cookies = RequestCookies::default();
        cookies.0.insert(key, value);
        req.extensions_mut().insert(cookies);
    }
}

pub struct CookieMiddleware;

impl CookieMiddleware {
    pub fn new() -> Self {
        Self
    }
}

impl<S, B> Transform<S, ServiceRequest> for CookieMiddleware
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error> + Clone + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type Transform = CookieMiddlewareService<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ready(Ok(CookieMiddlewareService { service }))
    }
}

pub struct CookieMiddlewareService<S> {
    service: S,
}


impl<S, B> Service<ServiceRequest> for CookieMiddlewareService<S>
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error> + Clone + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type Future = LocalBoxFuture<'static, Result<ServiceResponse<B>, Error>>;

    forward_ready!(service);

    fn call(&self, req: ServiceRequest) -> Self::Future {
        let service = self.service.clone();

        Box::pin(async move {
            let mut response = service.call(req).await?;

            let cookies_to_add: Vec<(String, String)> = if let Some(cookies) = response
                .request()
                .extensions()
                .get::<RequestCookies>()
            {
                cookies.0.iter()
                    .map(|(k, v)| (k.clone(), v.clone()))
                    .collect()
            } else {
                Vec::new()
            };

            for (key, value) in cookies_to_add {
                let cookie = cookie::Cookie::build(key, value)
                    .path("/")
                    .finish();
                response.response_mut().add_cookie(&cookie)?;
            }

            Ok(response)
        })
    }
}